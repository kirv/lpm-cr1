'' LPM.cr1 -- CR1000 program for Laser Precipitation Monitor at Fairbanks ARM test site
'' 20180422.4 Ken.Irving@alaska.edu

ConstTable

    '' instrument make and model:
    const LPM_NAME  = "Laser Precipitation Monitor"
    const LPM_MODEL = "5.4110.11.100"

    '' instrument operational settings:
    const LPM_ID = 0
    const LPM__COMMPORT = Com1
    const LPM_0_PRECIP_HRS = 24

''''''    1234567890123456

endConstTable

''        1234567890123456

public battery      : units battery = volts 
public panelTemp    : units panelTemp = deg C
public progSig as Long

datatable("Messages",1,1000)
    sample(1,progSig,uint2)
    sample(1,msg,string)
endDatatable

sub logmsg(optional s as string="MARK",
    t as string="", u as string="", v as string="", w as string="")
    dim msg as string * 80 = s
    if t != "" then msg += "," & t : if u != "" then msg += "," & u
    if v != "" then msg += "," & v : if w != "" then msg += "," & w
    calltable(Messages)
endsub 'logmsg

sub send_cmd(id as long, cmd as string, optional value=99999 as long)
    dim s as string
    dim slen
    s = ""
    if value = 99999 then
        sprintf(s, "%c%02u%s%c", chr(13), id, cmd, chr(13))
    else
        sprintf(s, "%c%02u%s%05u%c", chr(13), id, cmd, value, chr(13))
    endif
    '' s should now have format "RxxCCR" or "RxxCCnnnnnR"
    ''     where R=<CR>, xx=ID, CC=command, n=zero-padded arg

    '' proto: serialOut(PORT,OUTSTRING,WAITSTRING,NUMTRIES,TIMEOUT)
    ''    WAITSTRING: if "", look for echo of each character from instrument
    serialOut (LPM__COMMPORT,s,"",0,0)
endsub ' send_cmd

'' command DD: Get Diagnostic Data -- representing the state of the instrument
public T_interior   : units T_interior   = degC ' 1 - "interior temp [degC]"
public T_laserdrvr  : units T_laserdrvr  = degC ' 2 - "temp of laser driver 0-80 degC"
public I_laser      : units I_laser      = mA   ' 3 - "mean value laser current [1/100 mA]"
public V_control    : units V_control    = mV   ' 4 - "control voltage [mV] ref value:  ' 4010+/-5"
public V_optical    : units V_optical    = mV   ' 5 - "optical control [mV] / control variable"
public V_sensor     : units V_sensor     = V    ' 6 - "voltage sensor supply [1/10V]"
public I_laser_pane : units I_laser_pane = mA   ' 7 - "current page heating laser head [mA]"
public I_recvr_pane : units I_recvr_pane = mA   ' 8 - "current page heating receiver head [mA]"
public T_ambient    : units T_ambient    = degC ' 9 - "ambient temp [degC]"
public V_heating    : units V_heating    = V    ' 10 - "voltage heating supply [1/10V]"
public I_housing    : units I_housing    = mA   ' 11 - "current heating housing [mA]"
public I_heads      : units I_heads      = mA   ' 12 - "current heating heads [mA]"
public I_carriers   : units I_carriers   = mA   ' 13 - "current heating carriers [mA]"

'' command DX: Get Self Diagnostic -- 0 or 1 for 6 errors, 8 warnings
'' command FM: Get Error Count -- counts for each error and warning flag
public LPM_errors as long
public LPM_warnings as long

DataTable(LPM_diagnostics,1,-1)
  DataInterval(0,60,Sec,10)
  sample(1,progSig,uint2)
  sample(1,T_interior,fp2)
  sample(1,T_laserdrvr,fp2)
  sample(1,I_laser,fp2)
  sample(1,V_control,fp2)
  sample(1,V_optical,fp2)
  sample(1,V_sensor,fp2)
  sample(1,I_laser_pane,fp2)
  sample(1,I_recvr_pane,fp2)
  sample(1,T_ambient,fp2)
  sample(1,V_heating,fp2)
  sample(1,I_housing,fp2)
  sample(1,I_heads,fp2)
  sample(1,I_carriers,fp2)
  sample(1,LPM_errors,uint2)
  sample(1,LPM_warnings,uint2)
EndTable

sub get_LPM_state
    dim cmd_DD_output as string * 
    dim diag(13) as float
    send_cmd(LPM_ID, "DD")
    serialin(cmd_DD_output,LPM__PORT,300,chr(13),2233)
    T_interior = diag(1)
    T_laserdrvr = diag(2)       ' "temp of laser driver 0-80 degC"
    I_laser     = diag(3)/100   ' "mean value laser current [1/100 mA]"
    V_control   = diag(4)       ' "control voltage [mV] ref value: 4010+/-5"
    V_optical   = diag(5)       ' "optical control [mV] / control variable"
    V_sensor    = diag(6)/10    ' "voltage sensor supply [1/10V]"
    I_laser_pane= diag(7)       ' "current page heating laser head [mA]"
    I_recvr_pane= diag(8)       ' "current page heating receiver head [mA]"
    T_ambient   = diag(9)       ' "ambient temp [degC]"
    V_heating   = diag(10)/10   ' "voltage heating supply [1/10V]"
    I_housing   = diag(11)      ' "current heating housing [mA]"
    I_heads     = diag(12)      ' "current heating heads [mA]"
    I_carriers  = diag(13)      ' "current heating carriers [mA]"
endsub ' get_LPM_state


'''    1234567890123456

dim LPM_error_msg(6) as string
  LPM_error_msg(1) = "static signal out of allowed range"
  LPM_error_msg(2) = "laser temperature (analog) too high"
  LPM_error_msg(3) = "laser temperature (digital) too high"
  LPM_error_msg(4) = "laser current (analog) too high"
  LPM_error_msg(5) = "laser current (digital) too high"
  LPM_error_msg(6) = "sensor supply out of allowed range"

dim LPM_warning_msg(8) as string
  LPM_error_msg(1) = "current: pane heating laser head"
  LPM_error_msg(2) = "current: pane heating receiver head"
  LPM_error_msg(3) = "temperature sensor"
  LPM_error_msg(4) = "heating supply out of allowed range"
  LPM_error_msg(5) = "current: heating housing"
  LPM_error_msg(6) = "current: heating heads"
  LPM_error_msg(7) = "current: heating carriers"
  LPM_error_msg(8) = "control output laser power high"

sub get_LPM_errors
    dim s as string * 30
    dim flags(15) as string * 1 ' 6 errors, 8 warnings, 1 not used
    dim counts(15) as long
    dim error_map as long
    dim warning_map as long

    '' command DX: Get Self Diagnostic -- 0/1 for 6 errors, 8 warnings, 1 not used
    send_cmd(LPM_ID, "DX")
    serialin(s,LPM__PORT,300,chr(13),30)
    splitStr (s,flags,CHR(59),521,4)

    '' command FM: Get Error Count -- counts for each error and warning flag
    send_cmd(LPM_ID, "FM")
    serialin(s,LPM__PORT,300,chr(13),30)
    splitStr (s,counts,CHR(59),521,4)

    '' look at each error flag::
    for i = 1 to 6 do
        if flag i is true
            if error_map bit i was false
                logmsg( LPM_error_msg(i), "ACTIVE", counts(i) + " times")
            endif
            set error_map bit i true
        else ' flag i is false
            if error_map bit i was true
                logmsg( LPM_error_msg(i), "NOT ACTIVE", "count: " + counts(i))
            endif
            set error_map bit i false
        endif
    next i

    '' look at each warning flag::
    for i = 1 to 8 do
        if flag i + 6 is true
            if warning_map bit i was false
                logmsg( LPM_warning_msg(i), "ACTIVE", counts(i+6) + " times")
            endif
            set warning_map bit i true
        else ' flag i + 6 is false
            if warning_map bit i was true
                logmsg( LPM_warning_msg(i), "NOT ACTIVE", "count: " + counts(i+6))
            endif
            set warning_map bit i false
        endif
    next i

    '' at this point, ACTIVE or NOT ACTIVE messages have been logged, and
    '' error and warning bitmaps have been updated to reflect the current state

endsub ' check_LPM_errors

    
'' Data Telegram 5: Synop, Metar, Disdrometer, Auxiliary Measuring Channels
dim LPM_telegram_5 as string * 2233
public telegram_5_is_ok as boolean

DataTable(LPM_data,1,telegram_5_is_ok)
  DataInterval(0,60,Sec,10)
  Sample(1,LPM_telegram_5,String)
  Sample(1,progSig,uint2)
EndTable
    
function check_telegram_5 as boolean
    dim i = 0
    dim a
    dim sum = 0
    if len(data_telegram_5) != 2233 then return False
    if ascii(data_telegram_5(1,1,1)) != 2 then return False
    if ascii(data_telegram_5(1,1,2233)) != 3 then return False
    do
        i += 1
        a = ascii(data_telegram_5(1,1,i))
        if i = 2228 OR i = 2229 then
            '' convert checksum hex nibble "1" to 1, "A" to 10, etc.
            if a>=48 AND a<=57 then a=a-48 else if a>=65 AND a<=70 then a=a-55
            if i = 2228 then a = a * 16
        endif
        sum += a
    loop until i = 2233
    '' adding the checksum to the sum of bytes should result in 0x00 in last byte
    if sum && hex(FF00) != 0 then return False
    return True
endFunction ' check_telegram_5()

dim time(9)

beginProg
  
    progSig = status.ProgSignature

    '' the LPM powers up at 9600, so match that, set LPM to 115200, and match that:
    serialOpen (LPM__COMMPORT,9600,0,300,10000)
    send_cmd(LPM_ID,"BR",9)                        '' 5:9600, 6:19200, 9:115200
    serialOpen (LPM__COMMPORT,115200,0,300,10000)
    log_message("LPM set to 115200 using " + LPM__COMMPORT)

    '' set instrument command mode to "configuration":
    send_cmd(LPM_ID, "KY", 1)

    '' disable automatic telegram output (will use TR:5 instead)
    send_cmd(LPM_ID, "TM", 0)

    '' set the LPM clock from the logger at startup:
    realtime(time) '' 1:year, 2:month, 3:day, 4:hour, 5:minute, 6:second
    send_cmd(LPM_ID, "ZY", time(1) mod 100)
    send_cmd(LPM_ID, "ZN", time(2))
    send_cmd(LPM_ID, "zd", time(3))
    send_cmd(LPM_ID, "ZH", time(4))
    send_cmd(LPM_ID, "ZM", time(5))
    send_cmd(LPM_ID, "ZS", time(6))
    log_msg("LPM","CLOCK SET:", get_cmd("ZT"), get_cmd("ZB") & " hrs running")
    
    '' set instrument command mode back to "normal":
    send_cmd(LPM_ID, "KY", 0)

    Scan (60,sec,0,0)
        PanelTemp (panelTemp,_60Hz)
        Battery (battery)

        '' every minute, get telegram 5 from the LPM:
        send_cmd(LPM_ID, "TY", 5)
        serialIn(LPM_telegram_5,LPM__COMMPORT,300,chr(3),2333)
  
        ' 5) parse the data we want out of the string
        SplitStr (LPM_array(),LPM_telegram,CHR(59),521,4)
        LPM_code5m = LPM_array(5)
        LPM_intensityTot = LPM_array(12)
        LPM_intensityLiquid = LPM_array(13)
        LPM_intensitySolid = LPM_array(14)
        LPM_precipAmount = LPM_array(15)
        LPM_airTemp = LPM_array(519)
        LPM_numAllParticles = LPM_array(49)
        SerialFlush(LPM__COMMPORT)
          
        '' put intstrument in correct state if it's behaving strangely
        If LPM_airTemp = NAN
            'put LPM in configuration mode 
            s = CHR(13) & "00KY00001" & CHR(13)
            SerialOut (LPM__COMMPORT,s,"",0,0)
            'put LPM in polling mode 
            s = CHR(13) & "00TM00005" & CHR(13)
            SerialOut (LPM__COMMPORT,s,"",0,0)
            Delay (0,3,Sec)
            SerialFlush (LPM__COMMPORT)
        EndIf

        callTable LPM_data
        callTable LPM_diag
    NextScan
EndProg

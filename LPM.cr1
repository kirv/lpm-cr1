'' LPM.cr1 for UAF/ARM by Ken.Irving@alaska.edu 20180530.07

ConstTable
    const LPM_NAME  = "Laser Precipitation Monitor"
    const LPM_MODEL = "5.4110.11.100"
    const LPM_ID = 0
    const LPM__PORT = Com1      ' C1=Tx (db9F-pin3), C2=Rx (db9F-pin2)
    const LPM_D1_PARAM = 13
    const LPM_D2_PARAM = 19
    const LPM_D1__SE = 2
    const LPM_D2__SE = 3
    const LPM_0_PRECIP_HRS = 24
    const LPM_TELEGRAM = 8
    const STOP_AFTER_N_SCANS = 10
    const REMARKS = "5th try at handling ?? (LPM help) command"
endConstTable

const STX = chr(2)
const ETX = chr(3)
const LF = chr(10)
const CR = chr(13)
const SEMICOLON = ";"
const QUESTION = "?"
const BANG = "!"

public battery      : units battery = volts 
public panelTemp    : units panelTemp = deg C
public progSig as Long

public lpm_command as string * 10
public lpm_results as string * 2233
public lpm_err_msg as string * 80
public lpm_checksum as long 
public telegram_query_tries as long

dim telegram as string * 2233
dim LPM(524) as string

dim fh as long
dim bytes as long

public do_F(2) as float : units do_F = Hz   : alias do_F = d1_freq, d2_freq
public metar1 as string * 5
public metar2 as string * 5
dim d17(13,2) as float
dim d19(21,2) as float
dim metar_code(90) as string * 5

'' LPM error and warning flags:
public LPM_errors as long
public LPM_warnings as long
dim LPM_error(6) as string * 40
dim LPM_warning(9) as string * 40

'' LPM diagnostic analog data from DD[1..13]
public LPM_state_vars(13) as float
alias LPM_state_vars = T_interior__C, T_laserdrvr__C, I_laser__mA, _
    V_control__mV, V_optical__mV, V_sensor__V, I_laser_pane__mA, _
    I_recvr_pane__mA, T_ambient__C, V_heating__V, I_housing__mA, _
    I_heads__mA, I_carriers__mA

'' logmsg() puts up to 7 arguments into msg string, stores in table Messages:
'' alternatively, put anything in msg and callTable(Messages)
dim logger_time(9)
dim msg as string * 80
dataTable("Messages",1,100) : sample(1,progSig,uint2) : sample(1,msg,string) : endTable
sub logmsg(optional s as string * 80 = "MARK", _
    optional t as string * 40 = "", optional u as string * 40 = "", _
    optional v as string * 40 = "", optional w as string * 40 = "", _
    optional x as string * 40 = "", optional y as string * 40 = "")
    msg = s & " " & t & " " & u & " " & v & " " & w & " " & x & " " & y
    msg = trim(msg)
    calltable(Messages)
endsub

function lpm_calc_cksum(telegram as string * 2233) as long
    '' sum of non-checksum bytes plus checksum should result in 0x00 in last byte
    dim N as long, H as long, L as long, S as long, i as long
    N = len(telegram)
    H = ascii(telegram(1,1,N-5)) : L = ascii(telegram(1,1,N-4))
    S = 0 - H - L
    if H>=48 AND H<=57 then H-=48 else if H>=65 AND H<=70 then H-=55
    if L>=48 AND L<=57 then L-=48 else if L>=65 AND L<=70 then L-=55
    S += H*16 + L
    for i = 1 to N : S += ascii(telegram(1,1,i)) : next i
    return S
endFunction

function lpm_query(id as long, cmd as string, param as long) as string * 2233
    '' NOTE: param = -1 omits parameter
    dim value as long

    select case param
    case -1
        sprintf(lpm_command, "%02d%s", id, uppercase(cmd))
    case 0 to 99999
        sprintf(lpm_command, "%02d%s%05d", id, uppercase(cmd), param)
    case else
        lpm_err_msg = "rejected: invalid parameter" : lpm_command="" : lpm_results=""
        return QUESTION & QUESTION & lpm_err_msg
    endselect

    serialOut(LPM__PORT, CR & lpm_command & CR,"",0,0)
    
    select case uppercase(cmd)
    case "TR"
        serialIn(lpm_results,LPM__PORT,300,ETX,2233)
    case "??"
        serialIn(lpm_results,LPM__PORT,30,LF,2233)
        '' output begins with "User commands", so look for "U" below
    case else
        serialin(lpm_results,LPM__PORT,300,CR,80)
        lpm_results = mid(lpm_results, 1, len(lpm_results))
    endselect

    select case left(lpm_results,1)
    case BANG
        '' examples: "!00BR00005", "!00CI00002"
        select case mid(lpm_results,4,2)
        case "CI"
            lpm_err_msg = lpm_results
            select case right(lpm_results,1)
            case 0  : lpm_err_msg &= ": invalid parameter"      '' !00CI00000
            case 2  : lpm_err_msg &= ": unknown command"        '' !00CI00002
            case 4  : lpm_err_msg &= ": parameter out of range" '' !00CI00004
            case 8  : lpm_err_msg &= ": config mode required"   '' !00CI00008
            endselect
            return QUESTION & lpm_err_msg
        case uppercase(cmd)
            '' command confirmed, so return numeric parameter
            value = mid(lpm_results,6,5)
            lpm_err_msg = ""
            return value
        case else
            lpm_err_msg = "unexpected:" & lpm_results
            return QUESTION & QUESTION & lpm_err_msg
        endselect
    case STX
        '' framed telegram output with checksum
        lpm_checksum = lpm_calc_cksum(lpm_results)
        if (lpm_checksum and &h0FF) = 0 then
            lpm_err_msg = ""
            return lpm_results
        else
            lpm_results = QUESTION & mid(lpm_results,2,2233)
            sprintf(msg,"DEBUG: %s, length: %d, checksum bad: 0x%X", _
                    lpm_command, len(lpm_results), lpm_checksum)
            calltable Messages
            lpm_err_msg = "telegram checksum failed"
        endif
    case "U"
        '' LPM help output from "??" command starts with "User commands:"
        lpm_error = ""
        return lpm_results
    case else
        '' simple data output from DD, DX, FM, PT, DA, ZT
        lpm_err_msg = ""
        return lpm_results
    endselect
endfunction

DataTable(LPM_state,1,-1)
  DataInterval(0,60,Sec,0)
  sample(1,progSig,uint2)
  sample(13,LPM_state_vars,fp2)
  sample(1,LPM_errors,uint2)
  sample(1,LPM_warnings,uint2)
  sample(1,telegram_query_tries,uint2)
EndTable

dim lpm_error_msgs(6) as string * 40 = { _     '' LPM error flags are in DX[1..6]
    "static signal out of range", _
    "laser temp (analog) too high", _
    "laser temp (digital) too high", _
    "laser current (analog) too high", _
    "laser current (digital) too high", _
    "sensor supply out of range" _
}

dim lpm_warning_msgs(9) as string * 40 = { _   '' LPM warning flags are in DX[7..15]
    "current: pane heating laser head", _
    "current: pane heating receiver head", _
    "temperature sensor", _
    "heating supply out of allowed range", _
    "current: heating housing", _
    "current: heating heads", _
    "current: heating carriers", _
    "control output laser power high", _
    "not used" _
}

sub get_LPM_state
    dim i as long
    dim mask as long
    dim flag as long
    dim dd(13) as long
    dim dx(15) as long
    dim fm(15) as long
    dim got_counts as boolean
    dim msg as string * 60

    '' state vars (DD), errors and warnings (DX), and counts (FM)
    splitStr (dd(),lpm_query(LPM_ID,"DD",-1),SEMICOLON,13,5)
    splitStr (dx(),lpm_query(LPM_ID,"DX",-1),SEMICOLON,15,5)
    splitStr (fm(),lpm_query(LPM_ID,"FM",-1),SEMICOLON,15,5)

    '' LPM analog diagnostic data from DD[1..13]
    for i = 1 to 13
        LPM_state_vars(i) = dd(i)
        if i = 3 then I_laser__mA /= 100
        if i = 6 then V_sensor__V /= 10
        if i = 10 then V_heating__V /= 10
    next i

    '' LPM error flags are in DX[1..6], counts are in FM[1..6]
    mask = 1
    for i = 1 to 6
        msg = ""
        flag = dx(i)
        if flag = 1 and (LPM_errors AND mask) = 0 then
            LPM_errors = LPM_errors OR mask 
            sprintf(msg, "error %d: %s, %d times", lpm_error_msgs(i), fm(i))
        endif
        if flag = 0 and (LPM_errors AND mask) > 0 then
            LPM_errors = LPM_errors XOR mask 
            sprintf(msg, "error %d turned off: %s", lpm_error_msgs(i))
        endif
        if msg <> "" then logmsg(msg)
        mask *= 2
    next i

    '' LPM warning flags are in DX[7..15]), counts are in FM[7..15]
    mask = 1
    for i = 1 to 8
        msg = ""
        flag = dx(6+i)
        if flag = 1 and (LPM_warnings AND mask) = 0 then
            LPM_warnings = LPM_warnings OR mask 
            sprintf(msg, "warning %d: %s, %d times", 6+i, lpm_warning_msgs(i), fm(6+i))
        endif
        if flag = 0 and (LPM_warnings AND mask) > 0 then
            LPM_warnings = LPM_warnings XOR mask 
            sprintf(msg, "warning %d turned off: %s", lpm_warning_msgs(i))
        endif
        if msg <> "" then logmsg(msg)
        mask *= 2
    next i

endsub

DataTable(LPM,1,-1)
  dataInterval(0,60,Sec,10)
  sample(1,progSig,uint2)
  sample(1,telegram,String)
EndTable
    
sub init_synop_metar
    '' prep to transform D17 and D19 output frequency to METAR code string
    '' arrays for D17 (Table 4) and D19 (Table 5) relate frequency to SYNOP code
    '' array for METAR codes is indexed on SYNOP code, so is sparsely used
    d17(1,1) = 5        : d17(1,2) =    90  ''  metar_code(90) =  "NP"
    d17(2,1) = 10       : d17(2,2) =    51  ''  metar_code(51) = "-DZ"
    d17(3,1) = 20       : d17(3,2) =    52  ''  metar_code(52) =  "DZ"
    d17(4,1) = 25       : d17(4,2) =    41  ''  metar_code(41) = "-UP"
    d17(5,1) = 33.33    : d17(5,2) =    57  ''  metar_code(57) = "-RADZ"
    d17(6,1) = 41.66    : d17(6,2) =    58  ''  metar_code(58) =  "RADZ"
    d17(7,1) = 50       : d17(7,2) =    67  ''  metar_code(67) = "-RASN"
    d17(8,1) = 62.5     : d17(8,2) =    68  ''  metar_code(68) =  "RASN"
    d17(9,1) = 83.33    : d17(9,2) =    77  ''  metar_code(77) =  "SG"
    d17(10,1) = 100     : d17(10,2) =   71  ''  metar_code(71) = "-SN"
    d17(11,1) = 125     : d17(11,2) =   72  ''  metar_code(72) =  "SN"
    d17(12,1) = 166.67  : d17(12,2) =   75  ''  metar_code(75) =  "GS"
    d17(13,1) = 250     : d17(13,2) =   89  ''  metar_code(89) =  "GR"

    d19(1,1) = 2.5      : d19(1,2) =    41  :   metar_code(41) = "-UP"
    d19(2,1) = 5        : d19(2,2) =    42  :   metar_code(42) =  "UP"
    d19(3,1) = 10       : d19(3,2) =    90  :   metar_code(90) =  "NP"
    d19(4,1) = 15.15    : d19(4,2) =    51  :   metar_code(51) = "-DZ"
    d19(5,1) = 20       : d19(5,2) =    52  :   metar_code(52) =  "DZ"
    d19(6,1) = 22.73    : d19(6,2) =    53  :   metar_code(53) = "+DZ"
    d19(7,1) = 25       : d19(7,2) =    57  :   metar_code(57) = "-RADZ"
    d19(8,1) = 29.41    : d19(8,2) =    58  :   metar_code(58) =  "RADZ"
    d19(9,1) = 33.33    : d19(9,2) =    61  :   metar_code(61) = "-RA"
    d19(10,1) = 38.46   : d19(10,2) =   62  :   metar_code(62) =  "RA"
    d19(11,1) = 41.66   : d19(11,2) =   63  :   metar_code(63) = "+RA"
    d19(12,1) = 45.45   : d19(12,2) =   67  :   metar_code(67) = "-RASN"
    d19(13,1) = 50      : d19(13,2) =   68  :   metar_code(68) =  "RASN"
    d19(14,1) = 55.56   : d19(14,2) =   77  :   metar_code(77) =  "SG"
    d19(15,1) = 62.5    : d19(15,2) =   71  :   metar_code(71) = "-SN"
    d19(16,1) = 71.43   : d19(16,2) =   72  :   metar_code(72) =  "SN"
    d19(17,1) = 83.33   : d19(17,2) =   73  :   metar_code(73) = "+SN"
    d19(18,1) = 100     : d19(18,2) =   74  :   metar_code(74) = "-GS"
    d19(19,1) = 125     : d19(19,2) =   75  :   metar_code(75) =  "GS"
    d19(20,1) = 166.67  : d19(20,2) =   76  :   metar_code(76) = "+GS"
    d19(21,1) = 250     : d19(21,2) =   89  :   metar_code(89) =  "GR"
endsub

function freq_to_metar(param as long, f as float) as string * 5
    dim i as long
    if param = 17 
        for i=1 to 13
            if abs(d17(i,1)-f) < 1 then return metar_code(d17(i,2))
        next i
    else if param = 19 
        for i=1 to 21
            if abs(d19(i,1)-f) < 1 then return metar_code(d19(i,2))
        next i
    endif
    return "?????"
endfunction

beginProg
    progSig = status.ProgSignature
    if REMARKS <> "" then logmsg("REMARKS:",REMARKS)
    
    '' set logger port to match the LPM through the MD485 rs232-to-rs485 device
    serialOpen (LPM__PORT,9600,0,300,4000)

    '' put instrument in config mode:
    if lpm_query(LPM_ID,"KY",1) <> 1 then logmsg("CONFIG MODE FAILED")

    '' log LPM baud rate and interface mode (should be 9600, half duplex)
    logmsg("LPM baud rate, BR :", lpm_query(LPM_ID,"BR",-1), "(5=9600,6=19200,9=115200)")
    logmsg("LPM comm mode, BD :", lpm_query(LPM_ID,"BD",-1), "(0=full-,1=half-duplex)")

    '' configure automatic data telegram output and digital outputs:
    logmsg("LPM auto telegram output: TM :", lpm_query(LPM_ID,"TM",-1))
    logmsg("LPM digital channel D1 :", lpm_query(LPM_ID,"D1",LPM_D1_PARAM)
    logmsg("LPM digital channel D2 :", lpm_query(LPM_ID,"D2",LPM_D2_PARAM)

    '' set the LPM clock from the logger at startup:
    realtime(logger_time) '' 1:year, 2:month, 3:day, 4:hour, 5:minute, 6:second
    lpm_query(LPM_ID,"ZS", logger_time(6))
    lpm_query(LPM_ID,"ZM", logger_time(5))
    lpm_query(LPM_ID,"ZH", logger_time(4))
    lpm_query(LPM_ID,"ZD", logger_time(3))
    lpm_query(LPM_ID,"ZN", logger_time(2))
    lpm_query(LPM_ID,"ZY", logger_time(1) mod 100)
    logmsg("LPM clock set from logger:", lpm_query(LPM_ID,"ZT",-1))
    logmsg("LPM runtime:", lpm_query(LPM_ID,"ZB",-1), "hrs")

    '' put instrument in normal command mode:
    if lpm_query(LPM_ID,"KY",0) <> 0 then logmsg("WARNING: CONFIG MODE FAILED TO TURN OFF")

    init_synop_metar()

    Scan (60,sec,0,STOP_AFTER_N_SCANS)
        panelTemp (panelTemp,_60Hz)
        battery (battery)
        realtime(logger_time) '' 1:year, 2:month, 3:day, 4:hour, 5:minute, 6:second
        '' every minute, read data telegram from the LPM
        '' retry query if LPM returns "!TR00001", which means: telegram not available
        '' NOTE: STX has been replaced by "?" if the checksum failed!
        telegram_query_tries = 0
        do
            delay(0,1,sec)
            telegram = lpm_query(LPM_ID, "TR", LPM_TELEGRAM)
            telegram_query_tries += 1
        loop until telegram <> 1 or telegram_query_tries > 3
        callTable LPM
  
        SplitStr (LPM(),telegram,SEMICOLON,524,5)
        LPM(1) = right(LPM(1),2)    ' remove <STX> from LPM ID code NN
          
        '' read LPM digital output channels, resolve metar codes
        periodAvg(do_F(), 2, mV250, LPM_D1__SE, 0, 1, 50, 100, 1, 0)
        metar1 = freq_to_metar(LPM_D1_PARAM, d1_freq)
        metar2 = freq_to_metar(LPM_D2_PARAM, d2_freq)

        '' FOR TESTING, log a message with frequency and METAR codes:
        if metar1 <> "?????" OR metar2 <> "?????" then
            logmsg("freq =", d1_freq, ", D17 METAR =", metar1, ", D19 METAR =", metar2)
        endif

        get_LPM_state()
        callTable LPM_state

        '' TESTING LPM help command, "??"
        if lpm_query(LPM_ID,"??",-1) <> "" then
            fh = fileopen("USR:LPM-HELP.TXT","w",0)
            if fh = 0 then
                bytes = len(lpm_results)
                sprintf(lpm_error, "unable to write %d bytes to USR:LPM-HELP.TXT", _
                        len(lpm_results))
                logmsg("LPM ?? cmd :", lpm_error)
            else
                bytes = filewrite(fh, lpm_results, 0)
                logmsg("USR:LPM-HELP.TXT written with",bytes,"bytes")
                if fileclose(fh) <> 0 then logmsg("failed to close file")
                lpm_error = ""
            endif
        endif

        if timeIntoInterval(0,1,day) then
            '' emit message with several parameters, then zero precip total:
            logmsg("LPM:" & lpm_query(LPM_ID,"ZT",-1), _
                lpm_query(LPM_ID,"ZB",-1) & " hrs", _
                "errors:" + LPM_errors, _
                "warnings:" + LPM_warnings)
             '' LPM_precip_qty & " mm in " & lpm_query(LPM_ID,"PT",-1) & " hrs")
         '' lpm_query(LPM_ID,"RA")
        endif
    NextScan
EndProg

'' LPM.cr1 -- CR1000 program for Laser Precipitation Monitor at Fairbanks ARM test site
'' 20180421.6 Ken.Irving@alaska.edu

ConstTable

    '' instrument make and model:
    const LPM_NAME  = "Laser Precipitation Monitor"
    const LPM_MODEL = "5.4110.11.100"

    '' instrument operational settings:
    const LPM_ID = 0
    const LPM__COMMPORT = Com1
    const LPM_0_PRECIP_HRS = 24

''''''    1234567890123456

endConstTable

''        1234567890123456

public battery      : units battery = volts 
public panelTemp    : units panelTemp = deg C
public progSig as Long

datatable("Messages",1,1000)
    sample(1,progSig,uint2)
    sample(1,msg,string)
endDatatable

sub logmsg(optional s1 as string ="MARK", s2 as string="", s3 as string="",
            s4 as string="", s5 as string="", s6 as string="")
    dim msg as string * 80
    msg=s1
    if s2 != "" then msg = msg & "," & s2
    if s3 != "" then msg = msg & "," & s3
    if s4 != "" then msg = msg & "," & s4
    if s5 != "" then msg = msg & "," & s5
    if s6 != "" then msg = msg & "," & s6
    calltable(Messages)
endsub 'logmsg


sub send_cmd(id as long, cmd as string, optional value=99999 as long)
    dim s as string
    dim slen
    s = ""
    if value = 99999 then
        sprintf(s, "%c%02u%s%c", chr(13), id, cmd, chr(13))
    else
        sprintf(s, "%c%02u%s%05u%c", chr(13), id, cmd, value, chr(13))
    endif
    '' s should now have format "RxxCCR" or "RxxCCnnnnnR"
    ''     where R=<CR>, xx=ID, CC=command, n=zero-padded arg

    '' proto: serialOut(PORT,OUTSTRING,WAITSTRING,NUMTRIES,TIMEOUT)
    ''    WAITSTRING: if "", look for echo of each character from instrument
    serialOut (LPM__COMMPORT,s,"",0,0)
endsub ' send_cmd

'' command DD: Get Diagnostic Data, representing the state of the instrument
public T_interior   : units T_interior   = degC ' 1 - "interior temp [degC]"
public T_laserdrvr  : units T_laserdrvr  = degC ' 2 - "temp of laser driver 0-80 degC"
public I_laser      : units I_laser      = mA   ' 3 - "mean value laser current [1/100 mA]"
public V_control    : units V_control    = mV   ' 4 - "control voltage [mV] ref value:  ' 4010+/-5"
public V_optical    : units V_optical    = mV   ' 5 - "optical control [mV] / control variable"
public V_sensor     : units V_sensor     = V    ' 6 - "voltage sensor supply [1/10V]"
public I_laser_pane : units I_laser_pane = mA   ' 7 - "current page heating laser head [mA]"
public I_recvr_pane : units I_recvr_pane = mA   ' 8 - "current page heating receiver head [mA]"
public T_ambient    : units T_ambient    = degC ' 9 - "ambient temp [degC]"
public V_heating    : units V_heating    = V    ' 10 - "voltage heating supply [1/10V]"
public I_housing    : units I_housing    = mA   ' 11 - "current heating housing [mA]"
public I_heads      : units I_heads      = mA   ' 12 - "current heating heads [mA]"
public I_carriers   : units I_carriers   = mA   ' 13 - "current heating carriers [mA]"

'' commands DX and FM: Get Self Diagnostic, and Get Error Count
dim LPM_errors(15) as boolean
dim LPM_error_counts(15) as long

'' bit-mapped error/warning flags
public LPM_error_flags as long

'''    1234567890123456

DataTable(LPM_diagnostics,1,-1)
  DataInterval(0,60,Sec,10)
  sample(1,progSig,uint2)
  sample(1,T_interior,fp2)
  sample(1,T_laserdrvr,fp2)
  sample(1,I_laser,fp2)
  sample(1,V_control,fp2)
  sample(1,V_optical,fp2)
  sample(1,V_sensor,fp2)
  sample(1,I_laser_pane,fp2)
  sample(1,I_recvr_pane,fp2)
  sample(1,T_ambient,fp2)
  sample(1,V_heating,fp2)
  sample(1,I_housing,fp2)
  sample(1,I_heads,fp2)
  sample(1,I_carriers,fp2)
  sample(1,LPM_error_flags,uint2)
EndTable

sub get_LPM_state
    dim cmd_DD_output as string * 
    dim diag(13) as float
    send_cmd(LPM_ID, "DD")
    serialin(cmd_DD_output,LPM__PORT,300,chr(13),2233)
    T_interior = diag(1)
    T_laserdrvr = diag(2)       ' "temp of laser driver 0-80 degC"
    I_laser     = diag(3)/100   ' "mean value laser current [1/100 mA]"
    V_control   = diag(4)       ' "control voltage [mV] ref value: 4010+/-5"
    V_optical   = diag(5)       ' "optical control [mV] / control variable"
    V_sensor    = diag(6)/10    ' "voltage sensor supply [1/10V]"
    I_laser_pane= diag(7)       ' "current page heating laser head [mA]"
    I_recvr_pane= diag(8)       ' "current page heating receiver head [mA]"
    T_ambient   = diag(9)       ' "ambient temp [degC]"
    V_heating   = diag(10)/10   ' "voltage heating supply [1/10V]"
    I_housing   = diag(11)      ' "current heating housing [mA]"
    I_heads     = diag(12)      ' "current heating heads [mA]"
    I_carriers  = diag(13)      ' "current heating carriers [mA]"
endsub ' get_LPM_state


'' commands DX and FM: Get Self Diagnostic, and Get Error Count
dim LPM_errors(15) as boolean
dim LPM_error_counts(15) as long

'' bit-mapped error/warning flags
public LPM_errors as long
public LPM_warnings as long

'''    1234567890123456

dim LPM_error_msg(15) as string
  LPM_error_msg(1) = "ERROR: static signal out of allowed range"
  LPM_error_msg(2) = "ERROR: laser temperature (analog) too high"
  LPM_error_msg(3) = "ERROR: laser temperature (digital) too high"
  LPM_error_msg(4) = "ERROR: laser current (analog) too high"
  LPM_error_msg(5) = "ERROR: laser current (digital) too high"
  LPM_error_msg(6) = "ERROR: sensor supply out of allowed range"
  LPM_error_msg(7) = "WARNING: current: pane heating laser head"
  LPM_error_msg(8) = "WARNING: current: pane heating receiver head"
  LPM_error_msg(9) = "WARNING: temperature sensor"
  LPM_error_msg(10) = "WARNING: heating supply out of allowed range"
  LPM_error_msg(11) = "WARNING: current: heating housing"
  LPM_error_msg(12) = "WARNING: current: heating heads"
  LPM_error_msg(13) = "WARNING: current: heating carriers"
  LPM_error_msg(14) = "WARNING: control output laser power high"
  LPM_error_msg(15) = "not used"

sub check_LPM_errors
    dim s as string * 30
    dim errors(15) as string * 1
    dim bitmap as long
    send_cmd(LPM_ID, "DX")
    serialin(cs,LPM__PORT,300,chr(13),30)
    SplitStr (s(),errors,CHR(59),521,4)
    '' look at each entry, compare with current value, message if transition 
    for i = 1 to 15 do
        if errors(i) = "0" AND LPM_errmap &&
        

    next i

endsub ' check_LPM_errors

    
'' Data Telegram 5: Synop, Metar, Disdrometer, Auxiliary Measuring Channels
dim LPM_telegram_5 as string * 2233
public telegram_5_is_ok as boolean

DataTable(LPM_data,1,telegram_5_is_ok)
  DataInterval(0,60,Sec,10)
  Sample(1,LPM_telegram_5,String)
  Sample(1,progSig,uint2)
EndTable
    
function check_telegram_5 as boolean
    dim i = 0
    dim a
    dim sum = 0
    if len(data_telegram_5) != 2233 then return False
    if ascii(data_telegram_5(1,1,1)) != 2 then return False
    if ascii(data_telegram_5(1,1,2233)) != 3 then return False
    do
        i = i + 1
        a = ascii(data_telegram_5(1,1,i))
        if i = 2228 OR i = 2229 then
            '' convert checksum hex nibble "1" to 1, "A" to 10, etc.
            if a>=48 AND a<=57 then a=a-48 else if a>=65 AND a<=70 then a=a-55
            if i = 2228 then a = a * 16
        endif
        sum = sum + a
    loop until i = 2233
    '' adding the checksum to the sum of bytes should result in 0x00 in last byte
    if sum && hex(FF00) != 0 then return False
    return True
endFunction ' check_telegram_5()

dim time(9)


beginProg
  
    progSig = status.ProgSignature

    '' the LPM powers up at 9600, so match that, set LPM to 115200, and match that:
    serialOpen (LPM__COMMPORT,9600,0,300,10000)
    send_cmd(LPM_ID,"BR",9)                        '' 5:9600, 6:19200, 9:115200
    serialOpen (LPM__COMMPORT,115200,0,300,10000)
    log_message("LPM set to 115200 using " & LPM__COMMPORT)

    '' set instrument command mode to "configuration":
    send_cmd(LPM_ID, "KY", 1)

    '' disable automatic telegram output (will use TR:5 instead)
    send_cmd(LPM_ID, "TM", 0)

    '' set the LPM clock from the logger at startup:
    realtime(time) '' 1:year, 2:month, 3:day, 4:hour, 5:minute, 6:second
    send_cmd(LPM_ID, "ZY", time(1) mod 100)
    send_cmd(LPM_ID, "ZN", time(2))
    send_cmd(LPM_ID, "zd", time(3))
    send_cmd(LPM_ID, "ZH", time(4))
    send_cmd(LPM_ID, "ZM", time(5))
    send_cmd(LPM_ID, "ZS", time(6))
    log_msg("LPM","CLOCK SET:", get_cmd("ZT"), get_cmd("ZB") & " hrs running")
    
    '' set instrument command mode back to "normal":
    send_cmd(LPM_ID, "KY", 0)

    Scan (60,sec,0,0)
        PanelTemp (panelTemp,_60Hz)
        Battery (battery)

        '' every minute, get telegram 5 from the LPM:
        send_cmd(LPM_ID, "TY", 5)
        serialIn(LPM_telegram_5,LPM__COMMPORT,300,chr(3),2333)
  
        ' 5) parse the data we want out of the string
        SplitStr (LPM_array(),LPM_telegram,CHR(59),521,4)
        LPM_code5m = LPM_array(5)
        LPM_intensityTot = LPM_array(12)
        LPM_intensityLiquid = LPM_array(13)
        LPM_intensitySolid = LPM_array(14)
        LPM_precipAmount = LPM_array(15)
        LPM_airTemp = LPM_array(519)
        LPM_numAllParticles = LPM_array(49)
        SerialFlush(LPM__COMMPORT)
          
        '' put intstrument in correct state if it's behaving strangely
        If LPM_airTemp = NAN
            'put LPM in configuration mode 
            s = CHR(13) & "00KY00001" & CHR(13)
            SerialOut (LPM__COMMPORT,s,"",0,0)
            'put LPM in polling mode 
            s = CHR(13) & "00TM00005" & CHR(13)
            SerialOut (LPM__COMMPORT,s,"",0,0)
            Delay (0,3,Sec)
            SerialFlush (LPM__COMMPORT)
        EndIf

        callTable LPM_data
        callTable LPM_diag
    NextScan
EndProg

'' LPM.cr1 -- CR1000 program for Laser Precipitation Monitor at Fairbanks ARM test site
'' 20180516.61 Ken.Irving@alaska.edu

ConstTable
    '' instrument make and model:
    const LPM_NAME  = "Laser Precipitation Monitor"
    const LPM_MODEL = "5.4110.11.100"

    '' instrument operational settings:
    const LPM_ID = 0
    const LPM__COMMPORT = Com1      ' C1=Tx (db9F-pin3), C2=Rx (db9F-pin2)
    const LPM_DO1_PARAM = 17
    const LPM_DO2_PARAM = 19
    const LPM_DO1__SE = 2
    const LPM_DO2__SE = 3
    const LPM_0_PRECIP_HRS = 24
    const MAX_TM5_RETRIES = 3
endConstTable

'' some useful ascii character codes:
const ETX = chr(3)
const CR = chr(13)
const SEMICOLON = chr(59)

public battery      : units battery = volts 
public panelTemp    : units panelTemp = deg C
public progSig as Long

dim TM5_raw as string * 2233
public TM5_checksum as boolean      ' true if TM5_raw checksum is good
public TM5_bytes as long
public TM5_retries as long
public TM5_timer as long        : units TM5_timer = sec
public LPM(524) as string
alias LPM(5)   = LPM_code5m
alias LPM(15)  = LPM_precipAmount

public do1_freq as float    : units do1_freq = Hz
public do2_freq as float    : units do2_freq = Hz
public metar1 as string * 5
public metar2 as string * 5

'' LPM error and warning flags:
public LPM_errors as long
public LPM_warnings as long
dim LPM_error(6) as string * 40
dim LPM_warning(9) as string * 40
dim FM_raw as string * 80
dim LPM_err_count(15) as long
dim got_error_counts as boolean 

'' LPM diagnostic analog data from DD[1..13] or LPM[38..50]
public T_interior   : units T_interior   = degC ' 1: "interior temp [degC]"
public T_laserdrvr  : units T_laserdrvr  = degC ' 2: "laser driver temp 0-80 degC"
public I_laser      : units I_laser      = mA   ' 3: "laser current mean [1/100 mA]"
public V_control    : units V_control    = mV   ' 4: "control voltage [mV] ref value"
public V_optical    : units V_optical    = mV   ' 5: "optical control [mV]/control var"
public V_sensor     : units V_sensor     = V    ' 6: "voltage supply [1/10V]"
public I_laser_pane : units I_laser_pane = mA   ' 7: "laser pane heating current [mA]"
public I_recvr_pane : units I_recvr_pane = mA   ' 8: "receiver pane heating current [mA]"
public T_ambient    : units T_ambient    = degC ' 9: "ambient temp [degC]"
public V_heating    : units V_heating    = V    ' 10: "voltage heating supply voltage[1/10V]"
public I_housing    : units I_housing    = mA   ' 11: "heating housing current [mA]"
public I_heads      : units I_heads      = mA   ' 12: "heating heads current [mA]"
public I_carriers   : units I_carriers   = mA   ' 13: "heating carriers current [mA]"

dim logger_time(9)
dim msg as string * 80

dataTable("Messages",1,100)
    sample(1,progSig,uint2)
    sample(1,msg,string)
endTable

sub logmsg(optional s as string * 80 = "MARK", _
    optional t as string * 40 = "", optional u as string * 40 = "", _
    optional v as string * 40 = "", optional w as string * 40 = "", _
    optional x as string * 40 = "", optional y as string * 40 = "")
    msg = s & " " & t & " " & u & " " & v & " " & w & " " & x & " " & y
    msg = trim(msg)
    calltable(Messages)
endsub

sub lpm_cmd(cmd as string, optional value as long = 99999)
    dim s as string
    '' send an extra CR to clear the output buffer:
    serialOut (LPM__COMMPORT,CR,"",0,0)
    if value = 99999 then
        sprintf(s, "%02u%s%c", LPM_ID, cmd, CR)
    else
        sprintf(s, "%02u%s%05u%c", LPM_ID, cmd, value, CR)
    endif
    '' s is "xxCCR" or "xxCCnnnnnR", where xx=ID, CC=cmd, n=0-padded arg, R=<CR>
    serialOut (LPM__COMMPORT,s,"",0,0)
endsub

function get_lpm(cmd as string, optional value as long = 99999)
    dim s as string * 80
    lpm_cmd(cmd, value)
    serialin(s,LPM__COMMPORT,300,CR,2233)
    return s
endFunction

DataTable(LPM_state,1,-1)
  DataInterval(0,60,Sec,0)
  sample(1,progSig,uint2)
  sample(1,T_interior,fp2)
  sample(1,T_laserdrvr,fp2)
  sample(1,I_laser,fp2)
  sample(1,V_control,fp2)
  sample(1,V_optical,fp2)
  sample(1,V_sensor,fp2)
  sample(1,I_laser_pane,fp2)
  sample(1,I_recvr_pane,fp2)
  sample(1,T_ambient,fp2)
  sample(1,V_heating,fp2)
  sample(1,I_housing,fp2)
  sample(1,I_heads,fp2)
  sample(1,I_carriers,fp2)
  sample(1,LPM_errors,uint2)
  sample(1,LPM_warnings,uint2)
  sample(1,TM5_bytes,uint2)
  sample(1,TM5_retries,uint2)
  sample(1,TM5_timer,uint2)
EndTable

sub get_error_counts ' called if needed by get_LPM_errors() and get_LPM_warnings()
    '' LPM error and warning counts are from FM[1..6] and FM[7..15]
    lpm_cmd("FM")
    serialIn(FM_raw,LPM__COMMPORT,300,CR,80)
    SplitStr (LPM_err_count(),FM_raw,SEMICOLON,15,2)
    got_error_counts = True
endsub

sub get_LPM_errors ' called by get_LPM_state()
    dim i as long
    '' LPM error flags are from LPM[21..27] (also see DX[1..6])
    '' LPM error counts are from FX[1..6]
    for i = 1 to 6
        if LPM_errors AND &b01 << (i-1) = 0 AND LPM(20+i) = 1 then
            if NOT got_error_counts then get_error_counts()
            logmsg("ERROR:", LPM_error(i), "( count:", LPM_err_count(i), ")")
            LPM_errors = LPM_errors OR &b01 << (i-1) 
        endif
        if LPM_errors AND &b01 << (i-1) > 0 AND LPM(20+i) = 0 then
            logmsg("error off:", LPM_error(i))
            LPM_errors = LPM_errors OR NOT &b01 << (i-1) 
        endif
    next i
endsub

sub get_LPM_warnings ' called by get_LPM_state()
    dim i as long
    '' LPM warning flags are from LPM[28..36] (also see DX[7..15])
    '' LPM warning counts are from FX[7..15]
    for i = 1 to 8
        if LPM_warnings AND &b01 << (i-1) = 0 AND LPM(27+i) = 1 then
            if NOT got_error_counts then get_error_counts()
            logmsg("WARNING:", LPM_warning(i), "( count:", LPM_err_count(i+6), ")")
            LPM_warnings = LPM_warnings OR &b01 << (i-1) 
        endif
        if LPM_warnings AND &b01 << (i-1) > 0 AND LPM(27+i) = 0 then
            logmsg("warning off:", LPM_warning(i))
            LPM_warnings = LPM_warnings OR NOT &b01 << (i-1) 
        endif
    next i
endsub

sub get_LPM_state
    '' LPM analog diagnostic data from DD[1..13] or LPM[37..49]
    T_interior = LPM(36+1)
    T_laserdrvr = LPM(36+2)       ' "temp of laser driver 0-80 degC"
    I_laser     = LPM(36+3)/100   ' "mean value laser current [1/100 mA]"
    V_control   = LPM(36+4)       ' "control voltage [mV] ref value: 4010+/-5"
    V_optical   = LPM(36+5)       ' "optical control [mV] / control variable"
    V_sensor    = LPM(36+6)/10    ' "voltage sensor supply [1/10V]"
    I_laser_pane= LPM(36+7)       ' "current page heating laser head [mA]"
    I_recvr_pane= LPM(36+8)       ' "current page heating receiver head [mA]"
    T_ambient   = LPM(36+9)       ' "ambient temp [degC]"
    V_heating   = LPM(36+10)/10   ' "voltage heating supply [1/10V]"
    I_housing   = LPM(36+11)      ' "current heating housing [mA]"
    I_heads     = LPM(36+12)      ' "current heating heads [mA]"
    I_carriers  = LPM(36+13)      ' "current heating carriers [mA]"
    got_error_counts = False
    get_LPM_errors
    get_LPM_warnings
endsub

DataTable(LPM,TM5_checksum,-1)
  dataInterval(0,60,Sec,10)
  sample(1,TM5_raw,String)
  sample(1,progSig,uint2)
EndTable
    
function check_TM5_raw as boolean
    dim i as long
    dim a as string * 1
    dim sum as long
    if len(TM5_raw) <> 2233 then return False
    if ascii(TM5_raw(1,1,1)) <> 2 then return False
    if ascii(TM5_raw(1,1,2233)) <> 3 then return False
    i = 0
    sum = 0
    do
        i += 1
        a = ascii(TM5_raw(1,1,i))
        if i = 2228 OR i = 2229 then
            '' convert checksum hex nibble "1" to 1, "A" to 10, etc.
            if a>=48 AND a<=57 then a=a-48 else if a>=65 AND a<=70 then a=a-55
            if i = 2228 then a = a * 16
        endif
        sum += a
    loop until i = 2233
    '' adding the checksum to the sum of bytes should result in 0x00 in last byte
    if sum << 24 <> 0 then return False
    return True
endFunction

sub init_LPM_messages
    '' LPM error flags from LPM[21..27] or DX[1..6]
    LPM_error(1) = "static signal out of range"
    LPM_error(2) = "laser temp (analog) too high"
    LPM_error(3) = "laser temp (digital) too high"
    LPM_error(4) = "laser current (analog) too high"
    LPM_error(5) = "laser current (digital) too high"
    LPM_error(6) = "sensor supply out of range"

    '' LPM warning flags from LPM[28..36] or DX[7..15]
    LPM_warning(1) = "current: pane heating laser head"
    LPM_warning(2) = "current: pane heating receiver head"
    LPM_warning(3) = "temperature sensor"
    LPM_warning(4) = "heating supply out of allowed range"
    LPM_warning(5) = "current: heating housing"
    LPM_warning(6) = "current: heating heads"
    LPM_warning(7) = "current: heating carriers"
    LPM_warning(8) = "control output laser power high"
    LPM_warning(9) = "not used"
endSub

dim d17(13,2) as float
dim d19(21,2) as float
dim metar_code(90) as string * 5

sub init_synop_metar
    '' prep to transform D17 and D19 output frequency to METAR code string
    '' arrays for D17 (Table 4) and D19 (Table 5) relate frequency to SYNOP code
    '' array for METAR codes is indexed on SYNOP code, so is sparsely used

    d17(1,1) = 5        : d17(1,2) =    90  ''  metar_code(90) =  "NP"
    d17(2,1) = 10       : d17(2,2) =    51  ''  metar_code(51) = "-DZ"
    d17(3,1) = 20       : d17(3,2) =    52  ''  metar_code(52) =  "DZ"
    d17(4,1) = 25       : d17(4,2) =    41  ''  metar_code(41) = "-UP"
    d17(5,1) = 33.33    : d17(5,2) =    57  ''  metar_code(57) = "-RADZ"
    d17(6,1) = 41.66    : d17(6,2) =    58  ''  metar_code(58) =  "RADZ"
    d17(7,1) = 50       : d17(7,2) =    67  ''  metar_code(67) = "-RASN"
    d17(8,1) = 62.5     : d17(8,2) =    68  ''  metar_code(68) =  "RASN"
    d17(9,1) = 83.33    : d17(9,2) =    77  ''  metar_code(77) =  "SG"
    d17(10,1) = 100     : d17(10,2) =   71  ''  metar_code(71) = "-SN"
    d17(11,1) = 125     : d17(11,2) =   72  ''  metar_code(72) =  "SN"
    d17(12,1) = 166.67  : d17(12,2) =   75  ''  metar_code(75) =  "GS"
    d17(13,1) = 250     : d17(13,2) =   89  ''  metar_code(89) =  "GR"

    d19(1,1) = 2.5      : d19(1,2) =    41  :   metar_code(41) = "-UP"
    d19(2,1) = 5        : d19(2,2) =    42  :   metar_code(42) =  "UP"
    d19(3,1) = 10       : d19(3,2) =    90  :   metar_code(90) =  "NP"
    d19(4,1) = 15.15    : d19(4,2) =    51  :   metar_code(51) = "-DZ"
    d19(5,1) = 20       : d19(5,2) =    52  :   metar_code(52) =  "DZ"
    d19(6,1) = 22.73    : d19(6,2) =    53  :   metar_code(53) = "+DZ"
    d19(7,1) = 25       : d19(7,2) =    57  :   metar_code(57) = "-RADZ"
    d19(8,1) = 29.41    : d19(8,2) =    58  :   metar_code(58) =  "RADZ"
    d19(9,1) = 33.33    : d19(9,2) =    61  :   metar_code(61) = "-RA"
    d19(10,1) = 38.46   : d19(10,2) =   62  :   metar_code(62) =  "RA"
    d19(11,1) = 41.66   : d19(11,2) =   63  :   metar_code(63) = "+RA"
    d19(12,1) = 45.45   : d19(12,2) =   67  :   metar_code(67) = "-RASN"
    d19(13,1) = 50      : d19(13,2) =   68  :   metar_code(68) =  "RASN"
    d19(14,1) = 55.56   : d19(14,2) =   77  :   metar_code(77) =  "SG"
    d19(15,1) = 62.5    : d19(15,2) =   71  :   metar_code(71) = "-SN"
    d19(16,1) = 71.43   : d19(16,2) =   72  :   metar_code(72) =  "SN"
    d19(17,1) = 83.33   : d19(17,2) =   73  :   metar_code(73) = "+SN"
    d19(18,1) = 100     : d19(18,2) =   74  :   metar_code(74) = "-GS"
    d19(19,1) = 125     : d19(19,2) =   75  :   metar_code(75) =  "GS"
    d19(20,1) = 166.67  : d19(20,2) =   76  :   metar_code(76) = "+GS"
    d19(21,1) = 250     : d19(21,2) =   89  :   metar_code(89) =  "GR"
endsub

function freq_to_metar(param as long, f as float) as string * 5
    dim i as long
    if param = 17 
        for i=1 to 13
            if abs(d17(i,1)-f) < 1 then return metar_code(d17(i,2))
        next i
    else if param = 19 
        for i=1 to 21
            if abs(d19(i,1)-f) < 1 then return metar_code(d19(i,2))
        next i
    endif
    return "?????"
endfunction

beginProg
    progSig = status.ProgSignature

    '' the MD485 is fixed at 9600, so the LPM should be as well
    serialOpen (LPM__COMMPORT,9600,0,300,4000)

    '' put instrument in config mode:
    lpm_cmd("KY",1)
    lpm_cmd("BR",5)                        '' 5:9600, 6:19200, 9:115200
    lpm_cmd("BD",1)                        '' 0:rs422, 1:rs485 (half duplex)
    logmsg("LPM set to 9600, half duplex")

    '' set the LPM clock from the logger at startup:
    realtime(logger_time) '' 1:year, 2:month, 3:day, 4:hour, 5:minute, 6:second
    lpm_cmd("ZY", logger_time(1) mod 100)
    lpm_cmd("ZN", logger_time(2))
    lpm_cmd("ZD", logger_time(3))
    lpm_cmd("ZH", logger_time(4))
    lpm_cmd("ZM", logger_time(5))
    lpm_cmd("ZS", logger_time(6))
    logmsg("LPM","CLOCK SET:", get_lpm("ZT"), "runtime:", get_lpm("ZB"), "hrs")

    '' configure automatic data telegram 5 output:
    lpm_cmd("TM",5)

    '' configure digital outputs
  ' lpm_cmd("D1", 1)
  ' lpm_cmd("D2", 19)
    
    '' put instrument in normal command mode:
    lpm_cmd("KY", 0)

    init_LPM_messages
    init_synop_metar()

    Scan (60,sec,0,0)
        panelTemp (panelTemp,_60Hz)
        battery (battery)

        '' every minute, read data telegram 5 from the LPM, retry if necessary
        timer(1,sec,2)
        TM5_retries = 0
        serialIn(TM5_raw,LPM__COMMPORT,1500,ETX,2233)
        TM5_checksum = check_TM5_raw()
        do while TM5_checksum = False
            TM5_retries += 1
            lpm_cmd("TR",5)
            serialIn(TM5_raw,LPM__COMMPORT,300,ETX,2233)
            TM5_checksum = check_TM5_raw()
            if TM5_retries >= MAX_TM5_RETRIES then exitDo
            delay(0,1,sec)
        loop
        TM5_timer = timer(1,sec,1)
        TM5_bytes = len(TM5_raw)
        callTable LPM
  
        SplitStr (LPM(),TM5_raw,SEMICOLON,524,5)
        LPM(1) = right(LPM(1),2)    ' clean <STX> from LPM ID code NN
          
        '' get operating state of the LPM as analog values, binary errors and warnings:
        get_LPM_state
        callTable LPM_state

     '' '' FOR TESTING, COMMENT-OUT periodAvg() CALLS:
        '' read LPM digital output channels
     '' periodAvg(do_freq(), 2, mV250, LPM_DO1__SE, 0, 1, 50, 100, 1, 0)

        do1_freq = RND * 250
        do2_freq = do1_freq

        metar1 = freq_to_metar(LPM_DO1_PARAM, do1_freq)
        metar2 = freq_to_metar(LPM_DO2_PARAM, do2_freq)

        '' FOR TESTING, log a message with frequency and METAR codes:
        if metar1 <> "?????" OR metar2 <> "?????" then
            logmsg("freq =", do1_freq, ", D17 METAR =", metar1, ", D19 METAR =", metar2)
        endif

        if timeIntoInterval(0,1,day) then
            '' emit message with several parameters, then zero precip total:
            logmsg("LPM:" & get_lpm("ZT"), _
                get_lpm("ZB") & " hrs", _
                "errors:" + LPM_errors, _
                "warnings:" + LPM_warnings)
             '' LPM_precip_qty & " mm in " & get_lpm("PT") & " hrs")
            lpm_cmd("RA")
        endif

    NextScan
EndProg

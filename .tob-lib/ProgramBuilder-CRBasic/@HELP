NAME
    ProgramBuilder-CRBasic

DESCRIPTION
    ProgramBuilder-CRBasic is a thinobject type for building or
    composing programs for Campbell Scientific dataloggers in the
    CRBasic language.

    An object of this type contains components and properties that
    define the program text that will be generated by the 'build'
    method.

COMPONENTS
    A component of a datalogger program represents a subset of the
    program for a specific purpose, e.g., to provide code for a
    particular sensor.  The component includes list properties --
    text files with prefix '@' -- that are named to associate with
    methods that generate 'chunks' of the program.

    A component can be a directory in the builder object, or can
    be a symlink to a component in a prototype object.

COMPONENT PARAMETERS
    For any component, a symvar of the same name with ':' appended
    can be used to define parameters to be expanded in any of the
    chunk handlers for that component.  Component parameters are
    build-time variables with a namespace restricted to the component.

    In the component parameters symvar, parameters are declared
    like: NAME:VALUE, with parameter-value pairs separated by spaces.

    In component program text chunks, parameter expansions appear
    like {{NAME:VALUE}}.  The entire construct is replaced by VALUE
    unless parameter NAME is defined for the component, in which case 
    that value is used.

PROPERTIES
    ^   The ^ symlink identifies the ProgramBuilder-CRBasic type
        directly (as a non-resolving symlink) or indirectly as a
        symlink to a prototype object of the type.

    @order
        The @order file lists components to be included in the
        generated program.

    name
        The value of symvar 'name', if present, is output by the build
        method as a comment for the first line of the program. 

    tag
        Symvar tag's value is used as the prefix for the program
        output file obtained using the build --save option. 

    logger
        Symvar logger describes the datalogger model, used by the
        build --save option to set the progream extension.  Supported
        types include cr1000 (default), cr1000x, and cr800.

METHODS
    build
        The build method generates the complete program text, taking
        several optional arguments, then calling the following methods
        in turn to handle 'chunks' of the program, producing output in
        sequence:

            constants-table
            constants
            globals
            datatables
            functions
            subs
            programs
            after-notes

        The build method has several options; see build --help.


METHODS, CHUNK HANDLERS

    constants-table
        component property: @constants-table
        object symvars: FOO -> =VALUE replaces FOO value from @constatnts-table

        CRBasic constants declared in a constTable block can be edited
        using a keypad or by some terminal connection to the datalogger.

            constTable
                const NAME = VALUE
                ...
            endConstTable

        See next section:

    constants
        component property: @constants
        object symvars: FOO -> =VALUE replaces FOO value from @constatnts

        This method copies code found in '@constants' properties in each
        component listed in the '@order' property.  Constants look like:

            const NAME = VALUE

        where VALUE can be a quoted string or a numeric value.  Defined 
        constants can be used anywhere in the crbasic program where a value
        is expected, and VALUE will replace NAME.

        If defined in @constants or @constants-table, a symvar of the same 
        name can be declared in the build object, and the value will replace
        the value from the list property.

    globals
        component property: @globals
        object symvars: alias:NAME -> =VALUE
        
        This method includes code from @globals list property in any component
        listed in @order.

        Crbasic global declarations begin with the keyword 'dim' or 'public', 
        and define a variable name, optional array declaration, optional 
        crbasic data type, and optional value.  E.g., entries might look like:

            dim foo
            dim bar as string
            dim arr(5) as string * 60
            dim zip = 17
            dim zap(3) as string = { "one", "two", "three" }

        Variables declared with 'public' are visible at run-time via LoggerNet
        in the Public table, but otherwise are identical to 'dim' variables.

        Aliases are supported by crbasic to provide alternate names for variables
        or variable array elements, primarily for inclusion in datatable columns.
        From the above declarations, these could be declared:

            alias foo = myfoo
            alias arr() = first_el, second_el, third_el, fourth_el, fifth_el 

        Symvars in the build object with prefix alias:, e.g., alias:NAME, will be
        included in the program text if the associated NAME is declared as a global
        variable.  Aliases should be declared either in a @globals property or as
        alias:NAME symvars, but not both together.

    datatables
        component properties: @datatable:NAME
        object symvars: datatable-NAME:
        object symvars: datafield-TYPE:NAME

        Symvars declared in the build object as 'datatable-TABLE_NAME:' can be used
        to initialize datatable declarations in the generated program.  Supported 
        fields in the symvar value include:

            size:VALUE      -- -1 means: allocate all available memory
            interval:VALUE  -- VALUE is a number in seconds, optional suffix
            trigger:NAME

        Object symvars like 'datafield-TYPE:NAME' represent datatable column
        declarations, and are evaluated before any @datatable:NAME properties.
        Supported fields include:

            type:TYPE -- default type is fp2 (2-byte float)
            table:NAME
            tables:T1,T2,T3
            order:N

        Note: Use of 'datafield-TYPE:NAME' symvars is complicated by the need
        to maintain datatable columns in strict order.  One use is to declare
        a certain datatable field to be the first column.:w

        @datatable:NAME
            Each line in this list property represents a field declaration in
            the datatable NAME.   Lines other than for field elements are ignored,
            'datatable()' or 'endtable'.
        
                sample(NAME, REPS, TYPE)
                average(NAME, REPS, TYPE)
                min(NAME, REPS, TYPE)
                ...

    functions
        component properties: @function:NAME

        	The contents of each @function:NAME list property is output
        	as program text after component parameter expansion, but
        	with no other processing.  The function name is as defined
        	in the file, and may be different from NAME.  A convention
        	is for NAME to use '-' (hyphen) to separate portions of the
        	function name, while the function name in the program uses
            '_' (underscore) instead.

    subs
        component properties: @sub:NAME

        	The contents of each @sub:NAME list property is output
        	as program text after component parameter expansion, but
        	with no other processing.  The sub name is as defined
        	in the file, and may be different from NAME.  A convention
        	is for NAME to use '-' (hyphen) to separate portions of the
        	sub name, while the sub name in the program uses
            '_' (underscore) instead.

            (Note that CRBasic subroutines arguments use pass-by-reference;
            code in subroutines can change the state of global variables.)

    programs
        component properties: @prog:init
        component properties: @prog:SCAN
        component properties: @prog:N<UNITS>
        object symvar: scan-order

        Text lines found in @prog:* list properties are output into separate
        chunks for each scan interval.  @prog:init text precedes any scan block,
        so will run one time as the program starts up.

        The SCAN value is in seconds by default, but support may be added for
        other time intervals via the suffix, e.g., msec.

        Scan blocks are output in numeric order except if overridden by the
        symvar 'scan-order'.  Scan blocks are separated by a 'slowSequence' line,
        but do not need to be in a particular order.

    after-notes
        component property: @after-notes
        build method option: --no-notes

        Text in any @after-notes properties is appended as comments after the
        end of the program, unless build is called with --no-notes.
        
    parameters
        build method option: --show-params

        If --show-params is included in the build invocation, component parameters
        are shown after the end of the program as comments.  The component names
        and parameter values are formatted according to options to the parameters
        method.  See the build method text to see/edit how the parameters method
        is called.


UTILITY METHODS
    A few methods were found useful in the past...

    strip
        This is an awk script that strips spaces, blank lines, comments, and
        other non-functional parts of a crbasic program, in order to achieve
        a smaller program file size.

    deploy
        This method stores the generated program under deploy/, along with a 
        version run through the strip method, and including program signatures
        of original and unstripped versions in the name. 

    print-lines-crlf
        An awk script to ensure \r\n (CR + LF) line endings, which are required
        for CRBasic programs.  Hopefully build and other methods already output
        lines with DOS-like line endings, so this method is superfluous.
        
SEE ALSO    
    github.com/kirv/thinobject
    ProgramBuilder-CRBasic.build --help
    ProgramBuilder-CRBasic.parameters --help

AUTHOR
    ken.irving@alaska.edu 2008-2018

